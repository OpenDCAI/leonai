╔════════════════════════════════════════════════════════════════════════════════╗
║                    OpenClaw 设计 vs Leon 当前实现对比                           ║
╚════════════════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────────────────────────┐
│ OpenClaw 设计（文档中的理想状态）                                               │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  用户输入                                                                       │
│     │                                                                           │
│     ├─► 检查 AgentState ◄─────────────────────────────────────────┐            │
│     │                                                              │            │
│     ├─ ACTIVE ──► 检查 canInterrupt 标志 ──► 决定 steer/queue    │            │
│     │                                                              │            │
│     ├─ IDLE ────► 接受新任务 ──► 转移到 ACTIVE                   │            │
│     │                                                              │            │
│     ├─ SUSPENDED ► 队列消息 ──► 等待恢复                          │            │
│     │                                                              │            │
│     └─ 其他 ────► 拒绝输入                                        │            │
│                                                                    │            │
│  Agent 运行中                                                      │            │
│     │                                                              │            │
│     ├─ 每个工具调用后 ──► 检查 steer 队列                         │            │
│     │                    ├─ 有 steer ──► 跳过剩余工具调用         │            │
│     │                    └─ 无 steer ──► 继续执行                 │            │
│     │                                                              │            │
│     └─ 完成后 ──► 转移到 IDLE ──► 触发 followup 处理 ◄───────────┘            │
│                                                                                 │
│  状态转移驱动队列处理（自动化）                                                 │
│     │                                                                           │
│     ├─ ACTIVE → IDLE ──► 自动处理 followup 队列                  │            │
│     │                                                              │            │
│     ├─ ACTIVE → SUSPENDED ──► 保存检查点                         │            │
│     │                                                              │            │
│     └─ SUSPENDED → ACTIVE ──► 恢复执行                           │            │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│ Leon 当前实现（简化的布尔值方案）                                               │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  用户输入                                                                       │
│     │                                                                           │
│     ├─► 检查 _agent_running 布尔值 ◄──────────────────────────────┐            │
│     │                                                              │            │
│     ├─ true ──► 检查 queue_mode ──► 入队或中断                   │            │
│     │                                                              │            │
│     └─ false ─► 直接启动 Agent ──► 设置 _agent_running = true    │            │
│                                                                    │            │
│  Agent 运行中                                                      │            │
│     │                                                              │            │
│     ├─ 每个工具调用后 ──► 检查 steer 队列                         │            │
│     │                    ├─ 有 steer ──► 跳过剩余工具调用         │            │
│     │                    └─ 无 steer ──► 继续执行                 │            │
│     │                                                              │            │
│     └─ 完成后 ──► 手动调用 _process_followup_queue() ◄───────────┘            │
│                  ├─ 设置 _agent_running = true                                 │
│                  └─ 启动新的 Agent 运行                                        │
│                                                                                 │
│  问题：                                                                         │
│     • 无法区分 ACTIVE/IDLE/SUSPENDED 等不同状态                                │
│     • 状态转移不驱动队列处理（需要手动调用）                                    │
│     • 中断处理不完整（无法恢复）                                                │
│     • 无法实现复杂的状态驱动逻辑                                                │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘

╔════════════════════════════════════════════════════════════════════════════════╗
║                          消息路由决策树对比                                     ║
╚════════════════════════════════════════════════════════════════════════════════╝

OpenClaw 设计：
─────────────

用户输入
  │
  ├─ state == ACTIVE
  │   ├─ canInterrupt == true
  │   │   ├─ mode == INTERRUPT ──► 转移到 SUSPENDED，保存状态
  │   │   └─ mode != INTERRUPT ──► 入队 steer/collect
  │   └─ canInterrupt == false ──► 拒绝输入
  │
  ├─ state == IDLE
  │   ├─ 接受新任务 ──► 转移到 ACTIVE
  │   └─ 处理 followup 队列
  │
  ├─ state == SUSPENDED
  │   ├─ mode == RESUME ──► 恢复执行
  │   └─ mode != RESUME ──► 队列消息
  │
  └─ 其他状态 ──► 拒绝输入


Leon 当前实现：
──────────────

用户输入
  │
  ├─ _agent_running == true
  │   ├─ mode == INTERRUPT ──► 取消 worker
  │   └─ mode != INTERRUPT ──► 入队消息
  │
  └─ _agent_running == false ──► 启动 Agent


╔════════════════════════════════════════════════════════════════════════════════╗
║                        状态转移与队列处理的关系                                 ║
╚════════════════════════════════════════════════════════════════════════════════╝

OpenClaw 设计（状态驱动）：
──────────────────────────

状态转移事件 ──► 触发回调 ──► 自动处理队列

INITIALIZING ──► READY
  │
  └─► on_state_changed(INITIALIZING, READY)
      └─► 初始化完成，等待任务

READY ──► ACTIVE
  │
  └─► on_state_changed(READY, ACTIVE)
      └─► 开始执行任务

ACTIVE ──► IDLE
  │
  └─► on_state_changed(ACTIVE, IDLE)
      └─► 自动处理 followup 队列 ◄─── 关键！
          ├─ 如果有 followup ──► 转移回 ACTIVE
          └─ 如果无 followup ──► 保持 IDLE


Leon 当前实现（手动驱动）：
──────────────────────────

Agent 运行完成 ──► 手动调用 _process_followup_queue()
  │
  ├─ 检查 followup 队列
  ├─ 如果有 ──► 设置 _agent_running = true ──► 启动新运行
  └─ 如果无 ──► 设置 _agent_running = false ──► 等待用户输入

问题：需要在多个地方手动调用，容易遗漏或出错


╔════════════════════════════════════════════════════════════════════════════════╗
║                          中断和恢复机制对比                                     ║
╚════════════════════════════════════════════════════════════════════════════════╝

OpenClaw 设计：
──────────────

用户发送 INTERRUPT
  │
  ├─► 检查 state == ACTIVE
  │   ├─ 保存检查点（消息历史、执行状态）
  │   ├─ 转移到 SUSPENDED
  │   ├─ 取消 worker
  │   └─ 通知用户"已暂停，可恢复"
  │
  └─► 用户可以：
      ├─ 发送 RESUME ──► 恢复执行
      │   ├─ 恢复检查点
      │   ├─ 转移到 ACTIVE
      │   └─ 继续执行
      │
      └─ 发送新消息 ──► 重新开始
          ├─ 清空检查点
          ├─ 转移到 ACTIVE
          └─ 从头开始


Leon 当前实现：
──────────────

用户发送 INTERRUPT
  │
  ├─► 检查 _agent_running == true
  │   ├─ 取消 worker
  │   └─ 通知用户"已中断"
  │
  └─► 无法恢复
      └─ 用户只能重新开始
