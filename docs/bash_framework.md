## 10w Agent 终端方案总结

### 你澄清的关键问题

1. **"多个 agent 同时请求同一个 session 怎么办？"**
   - **你的回答**：不会发生，session 是 agent 的一部分（1 agent = 1 session）
   - **影响**：不需要并发锁，简化设计

2. **"复杂状态（venv/tmux）怎么办？"**
   - **你的回答**：允许被动清空，清空后用 prompt 告诉模型"这是新 session"，不允许模型主动清空
   - **影响**：只保存 cwd + env，不尝试恢复复杂状态

3. **"如何确定最大进程数 N？"**
   - **你的回答**：最大进程数（没说完整，但理解为"有限制"）
   - **影响**：需要设置合理配额

4. **"Agent 显式调用 save_session()"**
   - **你的回答**：不允许
   - **影响**：状态保存完全自动化，对 agent/模型透明

5. **"Blocking 能力"**
   - **你的问题**：是不是 blocking 就一定占用线程？
   - **我的解释**：用 asyncio 可以不占线程，但**进程数减少不了**
   - **你的反驳**：`npm run dev` 这种长期服务会一直占用进程，10w 个就爆了
   - **影响**：这是**致命问题**，推翻了之前的方案

---

### 方案演进过程

#### 初始方案（已推翻 ❌）
- Session Manager（10w 状态）+ Process Pool（1000 进程）+ LRU 淘汰
- **问题**：假设命令都是短命令，忽略了长期服务

#### 你的反驳（核心洞察 ✅）
- **`npm run dev` 例子**：长期服务不会退出，会一直占用进程
- **10w 个长期服务 = 10w 个进程** → 物理上不可能

---

### 最终方案结论

#### 核心认知
**一台机器跑不了 10w 个长期服务**，必须接受物理限制。

#### 设计原则
1. **区分命令类型**：
   - **短命令**（`ls`/`cat`/`git status`）：执行完立刻退出，无限制
   - **长期服务**（`npm run dev`/数据库/监控）：一直运行，需要配额管理

2. **配额策略**：
   - **系统级**：最多 1000 个总进程
   - **长期服务**：最多 500 个（留空间给短命令）
   - **Agent 级**：每个 agent 最多 3-5 个长期服务

3. **显式生命周期管理**（针对长期服务）：
   - `start_service(command)` → 启动服务，返回 service_id
   - `stop_service(service_id)` → 停止服务
   - `list_services()` → 查看当前 agent 的服务
   - 超配额 → 返回明确错误 + 建议停止其他服务

4. **自动清理**：
   - 服务超时（2 小时无活动）→ 自动停止
   - Agent 结束 → 清理其所有服务
   - 定期扫描僵尸进程

5. **状态持久化**（简化版）：
   - 只保存 `cwd` + `env`（基础状态）
   - 复杂状态（venv/tmux）丢失 → 提示模型"新 session"
   - 完全自动化，agent 不感知

6. **扩展方案**（如果单机不够）：
   - **分布式部署**：100 台机器 × 1000 进程 = 10w 进程
   - **Session Manager 用 Redis** 共享状态

---

### 架构设计（最终版）

```
┌─────────────────────────────────────────┐
│  10w Agents (asyncio 协程)              │
│  - 每个 agent 一个 session_id           │
│  - 不持有进程，只持有状态引用            │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│  Session Manager (状态管理)             │
│  - 10w 个 SessionState (内存/Redis)     │
│  - 只存 cwd + env，不存复杂状态          │
│  - 自动保存，agent 不感知                │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│  Command Executor (命令分类执行)        │
│  - 短命令：直接执行，完成即退出          │
│  - 长期服务：配额管理 + 显式生命周期     │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│  Process Pool (有限进程池)              │
│  - 短命令进程：按需创建，完成即销毁      │
│  - 长期服务进程：最多 500 个，显式管理   │
│  - LRU 淘汰（仅针对空闲的短命令进程）    │
└─────────────────────────────────────────┘
```

---

### 工具设计（最终版）

#### 1. `run_command` - 执行短命令或同步等待
```
参数：
  - command: 命令字符串
  - blocking: true（默认）
  - timeout: 30 秒（默认）
  - cwd: 可选（per-call 指定工作目录）

行为：
  - 执行命令，等待完成，返回结果
  - 进程执行完立刻退出
```

#### 2. `start_service` - 启动长期服务
```
参数：
  - command: 命令字符串
  - name: 服务名称（可选，用于标识）

返回：
  - service_id（成功）
  - 错误信息（超配额）

行为：
  - 检查配额（系统级 + agent 级）
  - 启动进程，记录 service_id
  - 进程持续运行，不会自动退出
```

#### 3. `stop_service` - 停止服务
```
参数：
  - service_id

行为：
  - 杀掉进程
  - 保存状态（cwd + env）
  - 释放配额
```

#### 4. `list_services` - 查看服务
```
返回：
  - 当前 agent 的所有服务列表
  - 每个服务的状态（running/stopped）
```

---

### MVP 实现优先级

**第一阶段（核心功能）**：
1. Session Manager（内存 dict）
2. 短命令执行（`run_command`，blocking=true）
3. 基础状态保存/恢复（cwd + env）
4. 进程配额限制（硬编码 1000）

**第二阶段（长期服务）**：
5. 长期服务管理（`start_service` / `stop_service` / `list_services`）
6. 配额检查（系统级 + agent 级）
7. 自动清理（超时 + agent 结束）

**第三阶段（生产优化）**：
8. 状态持久化（SQLite/Redis）
9. 分布式部署支持
10. 监控 + 动态配额调整

---

### 关键限制（必须接受）

1. **单机不可能跑 10w 个长期服务**
2. **需要合理配额 + 明确错误提示**
3. **复杂状态（venv/tmux）会丢失，不尝试恢复**
4. **扩展到 10w 需要分布式部署（多台机器）**